
# >>> TySP-Dev/Zsh-Functions: change-fastfetch.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: change-fastfetch
## Desc: Manage Fastfetch ASCII logos (list/show/create/set)
## Usage: change-fastfetch [--list|--show <file.txt>|--create|<file.txt>]
## Requires: awk, sed, nano
function change-fastfetch() {
  local DIR="$HOME/.config/fastfetch"
  local CFG="$DIR/config.jsonc"
  local LIST=() PICK FILE NEWPATH
  local usage="Usage:
  change-fastfetch --list
  change-fastfetch --show <name.txt>
  change-fastfetch --create
  change-fastfetch <name.txt>   # set as logo source"

  # Ensure base dir/config exists
  [[ -d "$DIR" ]] || { echo "âŒ Not found: $DIR"; return 1; }
  [[ -f "$CFG" ]] || { echo "âŒ Not found: $CFG"; return 1; }

  # helper: list .txt files (filenames only)
  _cf_list() {
    # zsh glob; fall back to find if needed
    local f
    for f in "$DIR"/*.txt(N); do
      [[ -e "$f" ]] && print -r -- "${f:t}"
    done
  }

  # helper: show a file
  _cf_show() {
    local name="$1"
    if [[ -z "$name" ]]; then
      echo "âŒ Missing filename. Usage: change-fastfetch --show <file.txt>"
      return 1
    fi
    if [[ "$name" == */* ]]; then
      echo "âŒ Pass only the basename like 'mushroom.txt'"
      return 1
    fi

    local path="$DIR/$name"
    if [[ ! -f "$path" ]]; then
      echo "âŒ Not found: $path"
      return 1
    fi

    echo "===== $name ====="
    if [[ -x /usr/bin/cat ]]; then
      /usr/bin/cat "$path"
    elif command -v cat >/dev/null 2>&1; then
      command cat "$path"
    elif command -v more >/dev/null 2>&1; then
      more -f "$path"
    else
      echo "âŒ No pager available (cat/more missing?)"
      return 1
    fi
  }

  # helper: show a file (avoid clobbering zsh's $path)
_cf_show() {
  local name="$1" logo_path
  if [[ -z "$name" ]]; then
    echo "âŒ Missing filename. Usage: change-fastfetch --show <file.txt>"
    return 1
  fi
  if [[ "$name" == */* ]]; then
    echo "âŒ Pass only the basename like 'mushroom.txt'"
    return 1
  fi

  logo_path="$DIR/$name"
  if [[ ! -f "$logo_path" ]]; then
    echo "âŒ Not found: $logo_path"
    return 1
  fi

  echo "===== $name ====="
  /usr/bin/cat "$logo_path"
}

  # helper: create a file using your editor
  _cf_create() {
    local name logo_path
    print -n "Enter new ASCII art filename (e.g., mylogo.txt): "
    read -r name
    [[ -z "$name" ]] && { echo "âŒ No name provided."; return 1; }
    [[ "$name" != *.txt ]] && name="${name}.txt"
    [[ "$name" == */* ]] && { echo "âŒ Use a simple name, not a path."; return 1; }

    logo_path="$DIR/$name"
    command touch -- "$logo_path" || { echo "âŒ Could not create $logo_path"; return 1; }
    chmod 600 -- "$logo_path"
    "${EDITOR:-nano}" "$logo_path"

    [[ -s "$logo_path" ]] && echo "âœ… Saved: $logo_path" || echo "â„¹ï¸ File exists but is empty: $logo_path"
  }

  # helper: update "logo.source" in JSONC (comment-tolerant)
  _cf_set_source() {
    local logo_path="$1"
    [[ -f "$logo_path" ]] || { echo "âŒ Not found: $logo_path"; return 1; }

    cp -f -- "$CFG" "$CFG.bak.$(date +%Y%m%d-%H%M%S)" || { echo "âŒ Backup failed"; return 1; }

    awk -v newsrc="$logo_path" '
      BEGIN { inlogo=0; done=0 }
      {
        line=$0
        if (match(line, /"logo"[[:space:]]*:/)) inlogo=1
        if (inlogo==1 && match(line, /"source"[[:space:]]*:/)) {
          sub(/"source"[[:space:]]*:[[:space:]]*"[^"]*"/, "\"source\": \"" newsrc "\"", line)
          done=1
        }
        print line
      }
    ' "$CFG" | awk -v newsrc="$logo_path" '
      BEGIN { inlogo=0; done=0 }
      { if ($0 ~ /"logo"[[:space:]]*:/) inlogo=1
        if (inlogo==1 && $0 ~ /"source"[[:space:]]*:/) done=1
        buf[NR]=$0
      }
      END {
        if (!done) {
          for (i=1;i<=NR;i++) {
            line=buf[i]
            if (inlogo==1 && line ~ /^[[:space:]]*}\s*,?$/ && !done) {
              sub(/^[[:space:]]*}\s*,?$/, "  \"source\": \"" newsrc "\"\n}", line)
              done=1
            }
            print line
          }
        } else {
          for (i=1;i<=NR;i++) print buf[i]
        }
      }
    ' > "$CFG.tmp" && mv -f -- "$CFG.tmp" "$CFG" || { echo "âŒ Failed to edit $CFG"; return 1; }

    echo "âœ… Updated logo source â†’ $logo_path"
  }

  # helper: update "logo.source" in JSONC via awk (comment-tolerant)
  _cf_set_source() {
    local logo_path="$1"
    [[ -f "$logo_path" ]] || { echo "âŒ Not found: $logo_path"; return 1; }

    # backup
    /usr/bin/cp -f -- "$CFG" "$CFG.bak.$(/usr/bin/date +%Y%m%d-%H%M%S)" || {
      echo "âŒ Backup failed"; return 1; }

    # replace or insert source inside "logo" object (comment-tolerant)
    /usr/bin/awk -v newsrc="$logo_path" '
      BEGIN { inlogo=0; done=0 }
      {
        line=$0
        if (match(line, /"logo"[[:space:]]*:/)) inlogo=1
        if (inlogo==1 && match(line, /"source"[[:space:]]*:/)) {
          sub(/"source"[[:space:]]*:[[:space:]]*"[^"]*"/, "\"source\": \"" newsrc "\"", line)
          done=1
        }
        print line
      }
    ' "$CFG" | /usr/bin/awk -v newsrc="$logo_path" '
      BEGIN { inlogo=0; done=0 }
      { if ($0 ~ /"logo"[[:space:]]*:/) inlogo=1
        if (inlogo==1 && $0 ~ /"source"[[:space:]]*:/) done=1
        buf[NR]=$0
      }
      END {
        if (!done) {
          for (i=1;i<=NR;i++) {
            line=buf[i]
            if (inlogo==1 && line ~ /^[[:space:]]*}\s*,?$/ && !done) {
              sub(/^[[:space:]]*}\s*,?$/, "  \"source\": \"" newsrc "\"\n}", line)
              done=1
            }
            print line
          }
        } else {
          for (i=1;i<=NR;i++) print buf[i]
        }
      }
    ' > "$CFG.tmp" || { echo "âŒ Edit failed"; return 1; }

    /usr/bin/mv -f -- "$CFG.tmp" "$CFG" || { echo "âŒ Could not write $CFG"; return 1; }
    echo "âœ… Updated logo source â†’ $logo_path"
  }

  case "$1" in
    --list)
      LIST=($(_cf_list))
      if (( ${#LIST} == 0 )); then
        echo "â„¹ï¸ No .txt logos found in $DIR"
      else
        printf '%s\n' "${LIST[@]}"
      fi
      ;;
    --show)
      shift
      _cf_show "$1"
      ;;
    --create)
      _cf_create
      ;;
    ""|-h|--help)
      echo "$usage"
      ;;
    *)
      # Treat as filename to set
      PICK="$1"
      [[ "$PICK" != *.txt ]] && PICK="${PICK}.txt"
      [[ "$PICK" == */* ]] && { echo "âŒ Pass only the basename like 'mushroom.txt'"; return 1; }
      FILE="$DIR/$PICK"
      [[ -f "$FILE" ]] || { echo "âŒ Not found: $FILE"; return 1; }
      NEWPATH="$FILE"
      _cf_set_source "$NEWPATH"
      ;;
  esac
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: clean-cache.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: clean-cache
## Desc: Clean package manager caches across different distros
## Usage: clean-cache
## Requires: (auto-detects available package managers)
function clean-cache() {
  local cleaned=0

  # Detect and clean pacman cache (Arch)
  if command -v paccache >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning pacman cache..."
    sudo paccache -r
    ((cleaned++))
  elif command -v pacman >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning pacman cache..."
    sudo pacman -Sc --noconfirm
    ((cleaned++))
  fi

  # Clean yay cache (Arch AUR)
  if command -v yay >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning yay cache..."
    yay -Sc --noconfirm
    ((cleaned++))
  fi

  # Clean apt cache (Debian/Ubuntu)
  if command -v apt >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning apt cache..."
    sudo apt clean
    sudo apt autoclean
    sudo apt autoremove -y
    ((cleaned++))
  fi

  # Clean dnf cache (Fedora/RHEL)
  if command -v dnf >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning dnf cache..."
    sudo dnf clean all
    sudo dnf autoremove -y
    ((cleaned++))
  fi

  # Clean Flatpak cache
  if command -v flatpak >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning Flatpak cache..."
    flatpak uninstall --unused -y
    ((cleaned++))
  fi

  # Clean Snap cache
  if command -v snap >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning Snap cache..."
    sudo snap set system refresh.retain=2
    # Remove old snap revisions
    local snap_list=$(snap list --all | awk '/disabled/{print $1, $3}')
    if [[ -n "$snap_list" ]]; then
      echo "$snap_list" | while read snapname revision; do
        sudo snap remove "$snapname" --revision="$revision" 2>/dev/null
      done
    fi
    ((cleaned++))
  fi

  # Clean Homebrew cache
  if command -v brew >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning Homebrew cache..."
    brew cleanup -s
    brew autoremove
    ((cleaned++))
  fi

  # Clean cargo cache
  if command -v cargo >/dev/null 2>&1; then
    if [[ -d "$HOME/.cargo/registry" ]]; then
      echo "ğŸ§¹ Cleaning cargo registry cache..."
      du -sh "$HOME/.cargo/registry" 2>/dev/null
      rm -rf "$HOME/.cargo/registry/index/"*
      rm -rf "$HOME/.cargo/registry/cache/"*
      ((cleaned++))
    fi
  fi

  # Clean npm cache
  if command -v npm >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning npm cache..."
    npm cache clean --force
    ((cleaned++))
  fi

  # Clean pip cache
  if command -v pip3 >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning pip cache..."
    pip3 cache purge 2>/dev/null || pip3 cache remove '*' 2>/dev/null
    ((cleaned++))
  elif command -v pip >/dev/null 2>&1; then
    echo "ğŸ§¹ Cleaning pip cache..."
    pip cache purge 2>/dev/null || pip cache remove '*' 2>/dev/null
    ((cleaned++))
  fi

  if (( cleaned == 0 )); then
    echo "â„¹ï¸  No package managers found to clean."
    return 1
  fi

  echo ""
  echo "âœ… Cache cleaning complete! ($cleaned package manager(s) cleaned)"
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: find-port.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: find-port
## Desc: Find processes using a specific port
## Usage: find-port <port>
## Requires: (lsof, ss, or netstat)
function find-port() {
  if [[ -z "$1" ]]; then
    echo "Usage: find-port <port>"
    return 1
  fi

  local port="$1"

  # Try lsof first (most detailed)
  if command -v lsof >/dev/null 2>&1; then
    sudo lsof -i :"$port"
  # Try ss (modern Linux)
  elif command -v ss >/dev/null 2>&1; then
    echo "ğŸ” Processes using port $port:"
    sudo ss -lptn "sport = :$port"
  # Try netstat (fallback)
  elif command -v netstat >/dev/null 2>&1; then
    echo "ğŸ” Processes using port $port:"
    sudo netstat -tulpn | grep ":$port "
  else
    echo "âŒ No suitable tool found (lsof, ss, or netstat required)"
    return 1
  fi
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: helpme.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: helpme
## Desc: Pretty list of your custom functions with usage
## Usage: helpme [name]
function helpme() {
  emulate -L zsh
  setopt noshwordsplit

  autoload -Uz colors && colors
  local B=$'\e[1m' Dim=$'\e[2m' R=$'\e[0m'
  local C="${fg[cyan]}" Y="${fg[yellow]}" G="${fg[green]}" reset="${reset_color}"

  local -a FUNCS=(
    "change-fastfetch|ğŸ¨|Manage Fastfetch ASCII logos|change-fastfetch [--list|--show <file.txt>|--create|<file.txt>]"
    "clean-cache|ğŸ§¹|Clean package manager caches (auto-detects distro)|clean-cache"
    "find-port|ğŸ”|Find processes using a specific port|find-port <port>"
    "hist|ğŸ“œ|Fuzzy-search command history with fzf and execute selection|hist"
    "ipinfo|ğŸŒ|Show local IP addresses and public IP|ipinfo"
    "killport|ğŸ›‘|Kill the process listening on a given port|killport <port>"
    "manage-backups|ğŸ—‚ï¸ |Manage and delete .zshrc backup files|manage-backups"
    "net-scan|ğŸ•¸ |Scan LAN for active devices (uses nmap)|net-scan [subnet]"
    "phone-wired|ğŸ“²|Connect phone via USB and launch scrcpy|phone-wired [full]"
    "phone-wireless|ğŸ“¶|Connect phone via Wi-Fi (ADB tcpip) and launch scrcpy|phone-wireless [full]"
    "update-functions|â¬†ï¸ |Check GitHub for function updates and apply them|update-functions [all]"
    "update-system|ğŸ”„|Universal system updater with customizable package managers|update-system [settings]"
    "weather|â›…|Show current weather (auto-detect by default)|weather [location]"
  )

  local target="$1"
  local namecol=24  # adjust if you want a wider name column

  # detail view
  if [[ -n "$target" ]]; then
    local f name emoji desc usage
    for f in "${FUNCS[@]}"; do
      IFS="|" read -r name emoji desc usage <<< "$f"
      if [[ "$name" == "$target" ]]; then
        printf "${B}${G}ğŸ“Œ %s${reset}${R}\n" "$name"
        printf "   %s %s\n" "$emoji" "$desc"
        printf "   %sUsage:%s %s%s%s\n" "$Dim" "$R" "$Y" "$usage" "$reset"
        echo
        return 0
      fi
    done
    printf "âŒ Unknown function: %s\n" "$target"
    return 1
  fi

  # list view â€” pad name first (plain), then color the padded block
  local f name emoji desc usage pname_pad
  for f in "${FUNCS[@]}"; do
    IFS="|" read -r name emoji desc usage <<< "$f"
    # truncate with â€¦ if longer than namecol
    local n="$name"
    (( ${#n} > namecol )) && n="${n[1,$((namecol-1))]}â€¦"
    # build a plain padded block, then wrap in color so width is preserved
    pname_pad=$(printf '%-*s' $namecol "$n")
    printf "%s %s%s%s â€” %s\n" \
      "$emoji" "$B$C" "$pname_pad" "$reset$R" "$desc"
  done

  echo
  printf "%sTip:%s use %shelpme <name>%s for usage\n" "$Dim" "$R" "$C" "$reset"
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: hist.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: hist
## Desc: Fuzzy-search command history with fzf and execute selection
## Usage: hist
## Requires: fzf, sed
function hist() {
  local selected
  selected=$(history | fzf --tac --reverse --height 40% --preview="echo {}" --preview-window=up:1:wrap --bind "enter:accept")
  if [ -n "$selected" ]; then
    local cmd=$(echo "$selected" | sed 's/ *[0-9]* *//')
    echo "âš¡ Executing: $cmd"
    eval "$cmd"
  fi
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: ipinfo.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: ipinfo
## Desc: Show local IP addresses and public IP
## Usage: ipinfo
## Requires: (ip, ifconfig, or ipconfig), curl
function ipinfo() {
  echo "ğŸ”’ Local IPs:"

  # Try ip command (modern Linux)
  if command -v ip >/dev/null 2>&1; then
    ip -o -4 addr show | awk '{print $2": "$4}'
  # Try ifconfig (macOS, BSD, older Linux)
  elif command -v ifconfig >/dev/null 2>&1; then
    ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
  # Try ipconfig (Windows via WSL)
  elif command -v ipconfig.exe >/dev/null 2>&1; then
    ipconfig.exe | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
  else
    echo "   âŒ No suitable tool found (ip, ifconfig, or ipconfig required)"
  fi

  echo ""
  echo "ğŸŒ Public IP:"

  # Try multiple services in case one is down
  if command -v curl >/dev/null 2>&1; then
    curl -s --max-time 5 https://api.ipify.org || \
    curl -s --max-time 5 https://ifconfig.me || \
    curl -s --max-time 5 https://icanhazip.com || \
    echo "âŒ Could not fetch public IP"
  elif command -v wget >/dev/null 2>&1; then
    wget -qO- --timeout=5 https://api.ipify.org || \
    wget -qO- --timeout=5 https://ifconfig.me || \
    wget -qO- --timeout=5 https://icanhazip.com || \
    echo "âŒ Could not fetch public IP"
  else
    echo "âŒ curl or wget required to fetch public IP"
  fi
  echo ""
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: killport.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: killport
## Desc: Kill the process listening on a given port
## Usage: killport <port>
## Requires: (lsof, ss, or netstat)
function killport() {
  if [[ -z "$1" ]]; then
    echo "Usage: killport <port>"
    return 1
  fi

  local port="$1"
  local pids=()

  # Try lsof first (most common)
  if command -v lsof >/dev/null 2>&1; then
    pids=(${(f)"$(sudo lsof -t -i tcp:"$port" 2>/dev/null)"})
  # Try ss (modern Linux)
  elif command -v ss >/dev/null 2>&1; then
    pids=(${(f)"$(sudo ss -lptn "sport = :$port" 2>/dev/null | awk 'NR>1 {match($0, /pid=([0-9]+)/, arr); if(arr[1]) print arr[1]}')"})
  # Try netstat (fallback)
  elif command -v netstat >/dev/null 2>&1; then
    pids=(${(f)"$(sudo netstat -tulpn 2>/dev/null | grep ":$port " | awk '{match($0, /([0-9]+)\//, arr); if(arr[1]) print arr[1]}')"})
  else
    echo "âŒ No suitable tool found (lsof, ss, or netstat required)"
    return 1
  fi

  if (( ${#pids} == 0 )); then
    echo "â„¹ï¸  No process found on port $port"
    return 0
  fi

  # Remove duplicates
  pids=(${(u)pids})

  echo "ğŸ›‘ Killing ${#pids} process(es) on port $port..."
  for pid in "${pids[@]}"; do
    sudo kill -9 "$pid" 2>/dev/null && echo "   âœ“ Killed PID $pid"
  done
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: manage-backups.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: manage-backups
## Desc: Manage .zshrc backup files with preview and deletion
## Usage: manage-backups
## Requires: fzf, awk
function manage-backups() {
  local ZSHRC="${ZSHRC:-$HOME/.zshrc}"
  local ZSHRC_DIR="$(dirname "$ZSHRC")"
  local MARK_PREFIX="# >>> TySP-Dev/Zsh-Functions:"
  local MARK_SUFFIX="# <<< TySP-Dev/Zsh-Functions"

  # Check requirements
  for cmd in fzf awk; do
    command -v "$cmd" >/dev/null 2>&1 || { echo "âŒ Missing required command: $cmd"; return 1; }
  done

  echo "ğŸ” Searching for .zshrc backup files..."

  # Find all backup files
  local -a backup_files=()
  backup_files=(${(f)"$(
    find "$ZSHRC_DIR" -maxdepth 1 -type f -name ".zshrc.bak.*" 2>/dev/null | sort -r
  )"})

  if (( ${#backup_files} == 0 )); then
    echo "â„¹ï¸  No backup files found in $ZSHRC_DIR"
    return 0
  fi

  echo "ğŸ“¦ Found ${#backup_files[@]} backup file(s)"
  echo ""

  # Helper: Extract functions from a backup file
  _extract_functions() {
    local file="$1"
    awk -v pre="$MARK_PREFIX" -v suf="$MARK_SUFFIX" '
      BEGIN { count=0 }
      index($0, pre) {
        rest = substr($0, index($0, pre) + length(pre))
        sub(/^[ \t]+/, "", rest)
        if (match(rest, /^[^ \t(]+/)) {
          funcs[count++] = substr(rest, RSTART, RLENGTH)
        }
      }
      END {
        if (count > 0) {
          for (i=0; i<count; i++) {
            printf "%s", funcs[i]
            if (i < count-1) printf ", "
          }
        } else {
          printf "none"
        }
      }
    ' "$file"
  }

  # Helper: Get file size
  _get_size() {
    local file="$1"
    if command -v du >/dev/null 2>&1; then
      du -h "$file" 2>/dev/null | awk '{print $1}'
    else
      echo "?"
    fi
  }

  # Helper: Get file timestamp from filename or modification time
  _get_timestamp() {
    local file="$1"
    local basename="${file##*/}"

    # Try to extract from filename: .zshrc.bak.YYYYMMDD-HHMMSS
    if [[ "$basename" =~ \.zshrc\.bak\.([0-9]{8}-[0-9]{6}) ]]; then
      local ts="${match[1]}"
      # Format: YYYYMMDD-HHMMSS -> YYYY-MM-DD HH:MM:SS
      echo "${ts:0:4}-${ts:4:2}-${ts:6:2} ${ts:9:2}:${ts:11:2}:${ts:13:2}"
    else
      # Fallback to modification time
      if command -v stat >/dev/null 2>&1; then
        if [[ "$OSTYPE" == "darwin"* ]]; then
          stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null
        else
          stat -c "%y" "$file" 2>/dev/null | cut -d'.' -f1
        fi
      else
        echo "unknown"
      fi
    fi
  }

  # Create preview script
  local TEMP_DIR="/tmp/zsh-manage-backups-$$"
  mkdir -p "$TEMP_DIR"
  trap "rm -rf '$TEMP_DIR'" EXIT INT TERM

  local preview_script="$TEMP_DIR/preview.sh"
  cat > "$preview_script" << 'PREVIEW_EOF'
#!/usr/bin/env zsh
file="$1"
MARK_PREFIX="# >>> TySP-Dev/Zsh-Functions:"
MARK_SUFFIX="# <<< TySP-Dev/Zsh-Functions"

if [[ ! -f "$file" ]]; then
  echo "âŒ File not found: $file"
  exit 1
fi

basename="${file##*/}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ğŸ“„ BACKUP FILE: $basename"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

# Show file info
if command -v stat >/dev/null 2>&1; then
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "ğŸ“… Created: $(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null || echo "unknown")"
    echo "ğŸ“Š Size: $(stat -f "%z bytes" "$file" 2>/dev/null || echo "unknown")"
  else
    echo "ğŸ“… Modified: $(stat -c "%y" "$file" 2>/dev/null | cut -d'.' -f1 || echo "unknown")"
    echo "ğŸ“Š Size: $(stat -c "%s bytes" "$file" 2>/dev/null || echo "unknown")"
  fi
fi

echo ""
echo "ğŸ“¦ Installed Functions:"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# List functions
awk -v pre="$MARK_PREFIX" '
  index($0, pre) {
    rest = substr($0, index($0, pre) + length(pre))
    sub(/^[ \t]+/, "", rest)
    if (match(rest, /^[^ \t(]+/)) {
      fname = substr(rest, RSTART, RLENGTH)
      # Extract timestamp if present
      if (match(rest, /\(.*\)/)) {
        tstamp = substr(rest, RSTART+1, RLENGTH-2)
        printf "  â€¢ %s (%s)\n", fname, tstamp
      } else {
        printf "  â€¢ %s\n", fname
      }
    }
  }
' "$file"

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ğŸ“ PREVIEW (first 30 lines):"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

if command -v bat >/dev/null 2>&1; then
  bat --style=numbers,changes --color=always --language=zsh --line-range=:30 "$file" 2>/dev/null
elif command -v cat >/dev/null 2>&1; then
  cat -n "$file" | head -30
else
  head -30 "$file"
fi
PREVIEW_EOF
  chmod +x "$preview_script"

  # Build menu items with info
  local -a menu_items=()
  local file size timestamp funcs

  for file in "${backup_files[@]}"; do
    size="$(_get_size "$file")"
    timestamp="$(_get_timestamp "$file")"
    funcs="$(_extract_functions "$file")"

    local basename="${file##*/}"
    menu_items+=("$basename|$timestamp|$size|$funcs|$file")
  done

  # Main loop - allow multiple operations
  while true; do
    echo "ğŸ” Select backup files to delete (or ESC to exit):"
    echo ""

    local -a selected=()
    selected=(${(f)"$(
      printf '%s\n' "${menu_items[@]}" | \
        awk -F'|' '{printf "ğŸ“¦ %-35s  ğŸ“… %-19s  ğŸ’¾ %-8s  ğŸ“‹ %s\n", $1, $2, $3, $4}' | \
        fzf -m \
            --prompt="Select backups to delete: " \
            --header="â¬†ï¸â¬‡ï¸ navigate â€¢ Space/Tab = select â€¢ Enter = delete â€¢ ESC = exit" \
            --bind 'space:toggle' \
            --bind 'tab:toggle' \
            --bind 'ctrl-a:select-all' \
            --bind 'ctrl-d:deselect-all' \
            --preview "zsh '$preview_script' {-1}" \
            --preview-window=right:65%:wrap \
            --height=90% \
            --border \
            --info=inline \
            --ansi
    )"})

    if (( ${#selected} == 0 )); then
      echo ""
      echo "ğŸ‘‹ No backups selected. Exiting."
      return 0
    fi

    # Extract file paths from selections
    local -a to_delete=()
    for item in "${menu_items[@]}"; do
      local display_line=$(echo "$item" | awk -F'|' '{printf "ğŸ“¦ %-35s  ğŸ“… %-19s  ğŸ’¾ %-8s  ğŸ“‹ %s\n", $1, $2, $3, $4}')
      for sel in "${selected[@]}"; do
        if [[ "$display_line" == "$sel"* ]]; then
          local filepath=$(echo "$item" | awk -F'|' '{print $5}')
          to_delete+=("$filepath")
        fi
      done
    done

    # Remove duplicates
    to_delete=(${(u)to_delete})

    echo ""
    echo "ğŸ—‘ï¸  Selected ${#to_delete[@]} backup(s) for deletion:"
    for file in "${to_delete[@]}"; do
      echo "   â€¢ ${file##*/}"
    done
    echo ""

    # Confirm deletion
    read "confirm?âš ï¸  Delete these backups? This cannot be undone! [y/N] "
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
      echo "âŒ Deletion cancelled"
      continue
    fi

    # Delete files
    local -i deleted=0
    local -i failed=0

    for file in "${to_delete[@]}"; do
      if rm -f "$file" 2>/dev/null; then
        echo "   âœ… Deleted: ${file##*/}"
        ((deleted++))

        # Remove from menu_items
        menu_items=(${menu_items:#*|$file})
      else
        echo "   âŒ Failed to delete: ${file##*/}"
        ((failed++))
      fi
    done

    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ… Deleted: $deleted"
    [[ $failed -gt 0 ]] && echo "âŒ Failed: $failed"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    # Check if any backups remain
    if (( ${#menu_items} == 0 )); then
      echo "âœ… All backups deleted!"
      return 0
    fi

    # Ask if user wants to continue
    read "continue?Continue managing backups? [Y/n] "
    if [[ "$continue" =~ ^[Nn]$ ]]; then
      echo ""
      echo "ğŸ‘‹ Exiting. ${#menu_items[@]} backup(s) remaining."
      return 0
    fi

    echo ""
  done
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: net-scan.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: net-scan
## Desc: Scan LAN for active devices (uses nmap)
## Usage: net-scan [subnet]
## Requires: ip, awk, nmap
function net-scan() {
  # Find default network interface
  local iface
  iface=$(ip route | awk '/^default/ {print $5; exit}')

  if [[ -z "$iface" ]]; then
    echo "âŒ Could not detect default network interface."
    return 1
  fi

  # Get CIDR for that interface
  local subnet
  subnet=$(ip -o -f inet addr show "$iface" | awk '{print $4}' | head -n1)

  if [[ -z "$subnet" ]]; then
    echo "âŒ Could not detect subnet for interface $iface."
    return 1
  fi

  echo "ğŸ” Scanning $subnet on interface $iface..."
  nmap -sn "$subnet"
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: scrcpy-helpers.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: scrcpy-helpers
## Desc: Connect phone via USB or Network and launch scrcpy
## Usage: phone-wired [full]
## Usage: phone-wireless [full]
## Requires: adb, scrcpy, fzf, awk, sed
function phone-wired() {
  local mode="${1:-}" usb_devices usb_device

  # sanity checks
  for cmd in adb scrcpy; do
    command -v "$cmd" >/dev/null 2>&1 || { echo "âŒ Missing $cmd"; return 1; }
  done

  while true; do
    usb_devices=(${(f)"$(
      adb devices | awk '/device$/{print $1}' | grep -vE '^[0-9]+\.[0-9]+\.[0-9]+:'
    )"})
    if (( ${#usb_devices} == 0 )); then
      echo "ğŸ“² Please plug in your phone via USB..."
      sleep 2
    else
      break
    fi
  done

  if (( ${#usb_devices} == 1 )); then
    usb_device="${usb_devices[1]}"
  else
    echo "ğŸ”Œ Multiple USB devices detected. Select one:"
    usb_device=$(printf "%s\n" "${usb_devices[@]}" | fzf --prompt="Choose USB device: ")
    [[ -z "$usb_device" ]] && echo "âŒ No device selected." && return 1
  fi

  echo "ğŸš€ Launching scrcpy on USB device: $usb_device"
  if [[ "$mode" == "full" ]]; then
    scrcpy -s "$usb_device" --fullscreen --audio-buffer=100 --video-bit-rate=8M
  else
    scrcpy -s "$usb_device"
  fi
}

##: Connect phone via Wi-Fi (ADB tcpip) and launch scrcpy
##: Usage: phone-wireless [full]
function phone-wireless() {
  local mode="${1:-}" connected_devices=() wireless_devices=() usb_devices=()
  local d usb_device wireless_device ip wireless_id started_with_usb=0

  # sanity checks
  for cmd in adb scrcpy; do
    command -v "$cmd" >/dev/null 2>&1 || { echo "âŒ Missing $cmd"; return 1; }
  done

  echo "NOTE: Press CTRL+C to exit"

  # helper: refresh device lists and partition by presence of ':'
  _pw_refresh() {
    connected_devices=(${(f)"$(adb devices | awk '/device$/{print $1}')"})
    wireless_devices=()
    usb_devices=()
    for d in "${connected_devices[@]}"; do
      if [[ "$d" == *:* ]]; then
        wireless_devices+=("$d")
      else
        usb_devices+=("$d")
      fi
    done
  }

  # loop until we either have a wireless device or at least one USB
  while true; do
    _pw_refresh
    if (( ${#wireless_devices} > 0 )); then
      # already wireless â€” pick one and launch immediately
      if (( ${#wireless_devices} == 1 )); then
        wireless_device="${wireless_devices[1]}"
      else
        echo "ğŸ“¶ Multiple wireless devices detected. Select one:"
        wireless_device=$(printf "%s\n" "${wireless_devices[@]}" | fzf --prompt="Choose wireless device: ")
        [[ -z "$wireless_device" ]] && echo "âŒ No device selected." && return 1
      fi
      echo "ğŸ“¶ Launching scrcpy for: $wireless_device"
      if [[ "$mode" == "full" ]]; then
        scrcpy -s "$wireless_device" --fullscreen --audio-buffer=100 --video-bit-rate=8M
      else
        scrcpy -s "$wireless_device"
      fi
      return 0
    fi

    # no wireless yet â€” need USB to kick off tcpip
    if (( ${#usb_devices} == 0 )); then
      echo "ğŸ“² Please plug in your phone via USB..."
      sleep 2
    else
      started_with_usb=1
      break
    fi
  done

  # Use the first USB device; add fzf here if you want selection
  usb_device="${usb_devices[1]}"
  echo "âœ… USB device detected: $usb_device"
  adb -s "$usb_device" tcpip 5555 || { echo "âŒ adb tcpip failed"; return 1; }
  sleep 1

  # Get device WLAN IP (strip CIDR if present)
  ip=$(adb -s "$usb_device" shell ip -o -4 addr show wlan0 | awk '{print $4}' | sed 's#/.*##' | head -n1)
  [[ -z "$ip" ]] && { echo "âŒ Failed to get IP address from wlan0"; return 1; }

  adb connect "$ip:5555" || { echo "âŒ adb connect $ip:5555 failed"; return 1; }
  echo "âœ… Connected to $ip:5555"

  # Only wait for unplug if we started wired
  if (( started_with_usb )); then
    echo "ğŸ”Œ Waiting for USB ($usb_device) to be unplugged..."
    while true; do
      _pw_refresh
      # is the original USB serial still present? if not, break
      local still_usb=0
      for d in "${usb_devices[@]}"; do
        [[ "$d" == "$usb_device" ]] && { still_usb=1; break; }
      done
      (( still_usb )) || break
      sleep 1
    done
    echo "ğŸ”Œ USB unplugged."
  fi

  wireless_id="${ip}:5555"
  echo "ğŸš€ Launching scrcpy over Wi-Fi: $wireless_id"
  if [[ "$mode" == "full" ]]; then
    scrcpy -s "$wireless_id" --fullscreen --audio-buffer=100 --video-bit-rate=8M
  else
    scrcpy -s "$wireless_id"
  fi
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: update-functions.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: update-functions
## Desc: Check GitHub for function updates and selectively update them
## Usage: update-functions [all]
## Requires: curl, awk (fzf optional for interactive mode)
function update-functions() {
  local ZSHRC="${ZSHRC:-$HOME/.zshrc}"
  local MARK_PREFIX="# >>> TySP-Dev/Zsh-Functions:"
  local MARK_SUFFIX="# <<< TySP-Dev/Zsh-Functions"
  local GITHUB_RAW="https://raw.githubusercontent.com/TySP-Dev/Zsh-Functions/main/functions"
  local TEMP_DIR="/tmp/zsh-functions-update-$$"
  local AUTO_UPDATE=0

  # Check if 'all' parameter was passed
  if [[ "$1" == "all" ]]; then
    AUTO_UPDATE=1
  fi

  # Check requirements (fzf only needed for interactive mode)
  for cmd in curl awk; do
    command -v "$cmd" >/dev/null 2>&1 || { echo "âŒ Missing required command: $cmd"; return 1; }
  done

  # Check fzf only if not in auto mode
  if (( AUTO_UPDATE == 0 )) && ! command -v fzf >/dev/null 2>&1; then
    echo "âŒ fzf is required for interactive mode"
    echo "   Use 'update-functions all' to update all available updates automatically"
    return 1
  fi

  [[ -f "$ZSHRC" ]] || { echo "âŒ .zshrc not found: $ZSHRC"; return 1; }

  echo "ğŸ” Scanning installed functions..."

  # Extract installed function names from .zshrc
  local -a installed_functions=()
  installed_functions=(${(f)"$(
    awk -v pre="$MARK_PREFIX" '
      index($0, pre) {
        rest = substr($0, index($0, pre) + length(pre))
        sub(/^[ \t]+/, "", rest)
        if (match(rest, /^[^ \t(]+/)) {
          print substr(rest, RSTART, RLENGTH)
        }
      }
    ' "$ZSHRC" | sort -u
  )"})

  if (( ${#installed_functions} == 0 )); then
    echo "â„¹ï¸  No installed functions found in $ZSHRC"
    echo "   Functions should be marked with:"
    echo "   $MARK_PREFIX <name>"
    echo "   $MARK_SUFFIX"
    return 0
  fi

  echo "ğŸ“¦ Found ${#installed_functions[@]} installed function(s): ${(j:, :)installed_functions}"
  echo ""

  # Create temp directory
  mkdir -p "$TEMP_DIR"
  trap "rm -rf '$TEMP_DIR'" EXIT INT TERM

  # Helper: Extract function from .zshrc
  _extract_installed() {
    local fname="$1"
    awk -v pre="$MARK_PREFIX" -v suf="$MARK_SUFFIX" -v nm="$fname" '
      BEGIN {found=0; inside=0}
      {
        if (!found && index($0, pre) && index($0, nm)) {
          found=1
          inside=1
          next
        }
        if (inside && index($0, suf)) {
          inside=0
          exit
        }
        if (inside) print
      }
    ' "$ZSHRC"
  }

  # Helper: Fetch function from GitHub
  _fetch_github() {
    local fname="$1"
    local url="$GITHUB_RAW/${fname}.zsh"
    curl -sf --max-time 10 "$url" 2>/dev/null
  }

  # Helper: Normalize function content (remove comments, blank lines, trailing whitespace)
  _normalize() {
    awk '
      /^[[:space:]]*##/ { next }
      /^[[:space:]]*$/ { next }
      { gsub(/[[:space:]]+$/, ""); print }
    '
  }

  echo "ğŸŒ Checking GitHub for updates..."
  local -a updates_available=()
  local -A update_status=()

  for fname in "${installed_functions[@]}"; do
    echo -n "   Checking $fname... "

    # Fetch from GitHub
    local github_content="$(_fetch_github "$fname")"
    if [[ -z "$github_content" ]]; then
      echo "âŒ Not found on GitHub"
      update_status[$fname]="not_found"
      continue
    fi

    # Extract installed version
    local installed_content="$(_extract_installed "$fname")"
    if [[ -z "$installed_content" ]]; then
      echo "âš ï¸  Could not extract from .zshrc"
      update_status[$fname]="error"
      continue
    fi

    # Save both versions to temp files
    echo "$installed_content" | _normalize > "$TEMP_DIR/${fname}.installed"
    echo "$github_content" | _normalize > "$TEMP_DIR/${fname}.github"

    # Compare normalized versions
    if diff -q "$TEMP_DIR/${fname}.installed" "$TEMP_DIR/${fname}.github" >/dev/null 2>&1; then
      echo "âœ… Up to date"
      update_status[$fname]="up_to_date"
    else
      echo "ğŸ†• Update available"
      update_status[$fname]="update_available"
      updates_available+=("$fname")

      # Save full GitHub version for later
      echo "$github_content" > "$TEMP_DIR/${fname}.new"
    fi
  done

  echo ""

  if (( ${#updates_available} == 0 )); then
    echo "âœ… All functions are up to date!"
    return 0
  fi

  echo "ğŸ“‹ ${#updates_available[@]} update(s) available: ${(j:, :)updates_available}"
  echo ""

  # Handle auto-update mode (update all)
  local -a to_update=()
  if (( AUTO_UPDATE == 1 )); then
    echo "ğŸ¤– Auto-update mode: Updating all available functions..."
    to_update=("${updates_available[@]}")
  else
    # Build fzf menu for interactive selection
    if ! command -v fzf >/dev/null 2>&1; then
      echo "âŒ fzf is required for interactive selection"
      echo "   Available updates: ${(j:, :)updates_available}"
      echo "   Use 'update-functions all' to update all automatically"
      return 1
    fi

  # Create preview helper script
  local preview_script="$TEMP_DIR/preview.sh"
  cat > "$preview_script" << 'PREVIEW_EOF'
#!/usr/bin/env zsh
fname="$1"
temp_dir="$2"

if [[ ! -f "$temp_dir/${fname}.installed" ]] || [[ ! -f "$temp_dir/${fname}.new" ]]; then
  echo "âŒ Preview not available"
  exit 1
fi

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ğŸ“ CHANGES FOR: $fname"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

if command -v diff >/dev/null 2>&1; then
  # Show unified diff with color if possible
  if diff --color=always -u "$temp_dir/${fname}.installed" "$temp_dir/${fname}.new" 2>/dev/null; then
    echo "No changes (identical)"
  fi
else
  echo "OLD VERSION:"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”"
  head -20 "$temp_dir/${fname}.installed"
  echo ""
  echo "NEW VERSION:"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”"
  head -20 "$temp_dir/${fname}.new"
fi
PREVIEW_EOF
    chmod +x "$preview_script"

    # Create menu items
    local -a menu_items=()
    for fname in "${updates_available[@]}"; do
      menu_items+=("ğŸ†• $fname - Update available")
    done

    echo "ğŸ” Select functions to update (Space/Tab to toggle, Enter to confirm):"
    echo ""

    local -a selected=()
    selected=(${(f)"$(
      printf '%s\n' "${menu_items[@]}" | \
        fzf -m \
            --prompt="Select functions to update: " \
            --header="â¬†ï¸â¬‡ï¸ navigate â€¢ Space/Tab = toggle â€¢ Enter = confirm â€¢ ESC = cancel" \
            --bind 'space:toggle' \
            --bind 'tab:toggle' \
            --bind 'ctrl-a:select-all' \
            --bind 'ctrl-d:deselect-all' \
            --preview "zsh '$preview_script' {2} '$TEMP_DIR'" \
            --preview-window=right:65%:wrap \
            --height=90% \
            --border \
            --info=inline
    )"})

    if (( ${#selected} == 0 )); then
      echo "â„¹ï¸  No functions selected for update"
      return 0
    fi

    # Extract function names from selections
    for item in "${selected[@]}"; do
      # Extract function name (second field)
      local fname=$(echo "$item" | awk '{print $2}')
      to_update+=("$fname")
    done
  fi

  echo ""
  echo "ğŸ“¥ Updating ${#to_update[@]} function(s)..."
  echo ""

  # Backup .zshrc
  local backup_file="${ZSHRC}.bak.$(date +%Y%m%d-%H%M%S)"
  cp -f "$ZSHRC" "$backup_file"
  echo "ğŸ§· Backup created: $backup_file"
  echo ""

  # Update each selected function
  local -i updated=0
  local -i failed=0

  for fname in "${to_update[@]}"; do
    echo "ğŸ”„ Updating $fname..."

    # Read the new content
    local new_content="$(<"$TEMP_DIR/${fname}.new")"
    if [[ -z "$new_content" ]]; then
      echo "   âŒ Failed to read new content"
      ((failed++))
      continue
    fi

    # Remove old version from .zshrc
    awk -v pre="$MARK_PREFIX" -v suf="$MARK_SUFFIX" -v nm="$fname" '
      BEGIN {del=0}
      {
        if (!del && index($0, pre) && index($0, nm)) { del=1; next }
        if (del && index($0, suf)) { del=0; next }
        if (!del) print
      }
    ' "$ZSHRC" > "${ZSHRC}.tmp"

    # Append new version
    {
      cat "${ZSHRC}.tmp"
      echo ""
      echo "$MARK_PREFIX $fname (updated $(date -Iseconds))"
      echo "$new_content"
      echo "$MARK_SUFFIX"
    } > "$ZSHRC"

    rm -f "${ZSHRC}.tmp"
    echo "   âœ… Updated successfully"
    ((updated++))
  done

  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "âœ… Update complete!"
  echo "   Updated: $updated"
  [[ $failed -gt 0 ]] && echo "   Failed: $failed"
  echo ""
  echo "ğŸ‘‰ Run: source \"$ZSHRC\" to apply changes"
  echo "   Backup: $backup_file"
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: update-system.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: update-system
## Desc: Universal system updater with customizable package manager support
## Usage: update-system [settings]
## Requires: fzf
function update-system() {
  local SETTINGS_FILE="$HOME/.config/zsh-functions/update-system.conf"
  local SETTINGS_DIR="$(dirname "$SETTINGS_FILE")"

  # Default settings
  local -A DEFAULT_SETTINGS=(
    [auto_detect]="true"
    [update_functions]="false"
    [pacman]="false"
    [apt]="false"
    [dnf]="false"
    [yay]="false"
    [flatpak]="false"
    [snap]="false"
    [brew]="false"
    [cargo]="false"
    [pip]="false"
    [npm]="false"
  )

  # Create settings directory if needed
  [[ -d "$SETTINGS_DIR" ]] || mkdir -p "$SETTINGS_DIR"

  # Load or create settings
  _load_settings() {
    if [[ -f "$SETTINGS_FILE" ]]; then
      source "$SETTINGS_FILE"
    else
      # First run - save defaults
      _save_settings
      return 1  # signal first run
    fi
    return 0
  }

  _save_settings() {
    {
      echo "# update-system settings"
      echo "# Generated on $(date)"
      echo ""
      for key val in "${(@kv)SETTINGS}"; do
        echo "${key}=${val}"
      done
    } > "$SETTINGS_FILE"
  }

  # Initialize settings
  typeset -A SETTINGS
  for key val in "${(@kv)DEFAULT_SETTINGS}"; do
    SETTINGS[$key]="$val"
  done

  # Check if this is first run
  local first_run=0
  _load_settings || first_run=1

  # Detect available package managers
  _detect_pm() {
    local -A detected
    command -v pacman >/dev/null 2>&1 && detected[pacman]="true"
    command -v apt    >/dev/null 2>&1 && detected[apt]="true"
    command -v dnf    >/dev/null 2>&1 && detected[dnf]="true"
    command -v yay    >/dev/null 2>&1 && detected[yay]="true"
    command -v flatpak>/dev/null 2>&1 && detected[flatpak]="true"
    command -v snap   >/dev/null 2>&1 && detected[snap]="true"
    command -v brew   >/dev/null 2>&1 && detected[brew]="true"
    command -v cargo  >/dev/null 2>&1 && detected[cargo]="true"
    command -v pip    >/dev/null 2>&1 && detected[pip]="true"
    command -v npm    >/dev/null 2>&1 && detected[npm]="true"

    # Return detected list
    for key val in "${(@kv)detected}"; do
      echo "$key"
    done
  }

  # Settings menu
  _settings_menu() {
    if ! command -v fzf >/dev/null 2>&1; then
      echo "âŒ fzf is required for the settings menu"
      echo "   Settings file: $SETTINGS_FILE"
      return 1
    fi

    local -a detected_pms=(${(f)"$(_detect_pm)"})
    local -a menu_items=()

    # Build menu with current status
    local pm status icon
    for pm in auto_detect update_functions pacman apt dnf yay flatpak snap brew cargo pip npm; do
      status="${SETTINGS[$pm]}"

      # Determine icon and availability
      if [[ "$pm" == "auto_detect" ]]; then
        icon="ğŸ”"
        if [[ "$status" == "true" ]]; then
          menu_items+=("$icon $pm [ENABLED] - Auto-detect and use all available package managers")
        else
          menu_items+=("$icon $pm [DISABLED] - Manually select package managers")
        fi
      elif [[ "$pm" == "update_functions" ]]; then
        icon="â¬†ï¸"
        if [[ "$status" == "true" ]]; then
          menu_items+=("$icon $pm [ON] - Update installed zsh functions from GitHub")
        else
          menu_items+=("$icon $pm [OFF] - Skip function updates")
        fi
      else
        # Check if available
        if (( ${detected_pms[(Ie)$pm]} )); then
          icon="âœ…"
        else
          icon="âŒ"
        fi

        if [[ "$status" == "true" ]]; then
          menu_items+=("$icon $pm [ON] - Available and enabled")
        else
          menu_items+=("$icon $pm [OFF] - $(if (( ${detected_pms[(Ie)$pm]} )); then echo "Available"; else echo "Not installed"; fi)")
        fi
      fi
    done

    menu_items+=("ğŸ’¾ Save and Exit")

    while true; do
      local selected
      selected=$(printf '%s\n' "${menu_items[@]}" | \
        fzf --prompt="âš™ï¸  Update System Settings: " \
            --header="Press ENTER to toggle â€¢ ESC to cancel" \
            --height=90% \
            --border \
            --reverse \
            --info=inline)

      [[ -z "$selected" ]] && echo "âŒ Cancelled" && return 1

      if [[ "$selected" == "ğŸ’¾ Save and Exit" ]]; then
        _save_settings
        echo "âœ… Settings saved to $SETTINGS_FILE"
        return 0
      fi

      # Extract PM name from selection
      local pm_name=$(echo "$selected" | awk '{print $2}')

      # Toggle the setting
      if [[ "${SETTINGS[$pm_name]}" == "true" ]]; then
        SETTINGS[$pm_name]="false"
      else
        # Don't allow enabling if not installed (except auto_detect and update_functions)
        if [[ "$pm_name" != "auto_detect" ]] && [[ "$pm_name" != "update_functions" ]] && ! (( ${detected_pms[(Ie)$pm_name]} )); then
          echo "âš ï¸  $pm_name is not installed on this system"
          sleep 1
        else
          SETTINGS[$pm_name]="true"
        fi
      fi

      # Rebuild menu
      menu_items=()
      for pm in auto_detect update_functions pacman apt dnf yay flatpak snap brew cargo pip npm; do
        status="${SETTINGS[$pm]}"

        if [[ "$pm" == "auto_detect" ]]; then
          icon="ğŸ”"
          if [[ "$status" == "true" ]]; then
            menu_items+=("$icon $pm [ENABLED] - Auto-detect and use all available package managers")
          else
            menu_items+=("$icon $pm [DISABLED] - Manually select package managers")
          fi
        elif [[ "$pm" == "update_functions" ]]; then
          icon="â¬†ï¸"
          if [[ "$status" == "true" ]]; then
            menu_items+=("$icon $pm [ON] - Update installed zsh functions from GitHub")
          else
            menu_items+=("$icon $pm [OFF] - Skip function updates")
          fi
        else
          if (( ${detected_pms[(Ie)$pm]} )); then
            icon="âœ…"
          else
            icon="âŒ"
          fi

          if [[ "$status" == "true" ]]; then
            menu_items+=("$icon $pm [ON] - Available and enabled")
          else
            menu_items+=("$icon $pm [OFF] - $(if (( ${detected_pms[(Ie)$pm]} )); then echo "Available"; else echo "Not installed"; fi)")
          fi
        fi
      done
      menu_items+=("ğŸ’¾ Save and Exit")
    done
  }

  # Update functions for each package manager
  _update_pacman() {
    echo "ğŸ”„ Updating system packages (pacman)..."
    sudo pacman -Syu --noconfirm
  }

  _update_apt() {
    echo "ğŸ”„ Updating system packages (apt)..."
    sudo apt update && sudo apt upgrade -y
  }

  _update_dnf() {
    echo "ğŸ”„ Updating system packages (dnf)..."
    sudo dnf upgrade -y
  }

  _update_yay() {
    echo "ğŸ“¦ Updating AUR packages (yay)..."
    yay -Syu --noconfirm
  }

  _update_flatpak() {
    echo "ğŸ“¦ Updating Flatpak packages..."
    flatpak update -y
  }

  _update_snap() {
    echo "ğŸ“¦ Updating Snap packages..."
    sudo snap refresh
  }

  _update_brew() {
    echo "ğŸº Updating Homebrew packages..."
    brew update && brew upgrade
  }

  _update_cargo() {
    echo "ğŸ¦€ Updating Rust crates..."
    if command -v cargo-install-update >/dev/null 2>&1; then
      cargo install-update -a
    else
      echo "   â„¹ï¸  cargo-update not installed. Install with: cargo install cargo-update"
    fi
  }

  _update_pip() {
    echo "ğŸ Updating pip packages..."
    if command -v pip3 >/dev/null 2>&1; then
      pip3 list --outdated --format=freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -r -n1 pip3 install -U --user
    else
      pip list --outdated --format=freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -r -n1 pip install -U --user
    fi
  }

  _update_npm() {
    echo "ğŸ“¦ Updating global npm packages..."
    npm update -g
  }

  _update_update_functions() {
    echo "â¬†ï¸ Updating zsh functions from GitHub..."
    if command -v update-functions >/dev/null 2>&1; then
      update-functions all
    else
      echo "   âš ï¸  update-functions command not found"
      echo "   Make sure the update-functions.zsh function is installed"
      return 1
    fi
  }

  # Main logic
  if [[ "$1" == "settings" ]]; then
    _settings_menu
    return $?
  fi

  # First run: show settings menu
  if (( first_run )); then
    echo "ğŸ‘‹ Welcome! This is your first time running update-system."
    echo "   Let's configure which package managers to use."
    echo ""
    _settings_menu || return 1
    echo ""
  fi

  # Determine which package managers to update
  local -a to_update=()

  # Check if update_functions is enabled
  if [[ "${SETTINGS[update_functions]}" == "true" ]]; then
    to_update+=("update_functions")
  fi

  if [[ "${SETTINGS[auto_detect]}" == "true" ]]; then
    echo "ğŸ” Auto-detecting available package managers..."
    to_update+=(${(f)"$(_detect_pm)"})
  else
    # Use manual selections
    for pm in pacman apt dnf yay flatpak snap brew cargo pip npm; do
      if [[ "${SETTINGS[$pm]}" == "true" ]] && command -v "$pm" >/dev/null 2>&1; then
        to_update+=("$pm")
      fi
    done
  fi

  if (( ${#to_update} == 0 )); then
    echo "âŒ No package managers or update options enabled."
    echo "   Run 'update-system settings' to configure."
    return 1
  fi

  echo "ğŸ“‹ Updating: ${(j:, :)to_update}"
  echo ""

  # Execute updates
  for pm in "${to_update[@]}"; do
    "_update_$pm" || echo "âš ï¸  Update failed for $pm"
    echo ""
  done

  echo "âœ… System update complete!"
}
# <<< TySP-Dev/Zsh-Functions

# >>> TySP-Dev/Zsh-Functions: weather.zsh (installed 2025-11-17T20:28:35-10:00)
## Name: weather
## Desc: Show current weather for a location (defaults to auto-detect)
## Usage: weather [location]
## Requires: curl
function weather() {
  local location="${1:-}"
  curl -s "wttr.in/${location}?format=3"
}
# <<< TySP-Dev/Zsh-Functions
